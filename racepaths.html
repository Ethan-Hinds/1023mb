<html>
    <head>
        <meta charset="UTF-8" />
        <script src="https://cdn.jsdelivr.net/npm/p5@0.7.2/lib/p5.min.js"></script>
    </head>
    <body>
        <div id="mapInfo">
            <label> Width of map </label>
            <input type="text" id="width" value="100">
            <label> Height of map </label>
            <input type="text" id="height" value="100">
            <label> Start x </label>
            <input type="text" id="startX" value="10">
            <label> Start y </label>
            <input type="text" id="startY" value="10">
            <br>
            <button onclick="start()"> Start </button>
        </div>
        <div id="data" style="visibility: hidden;">
            <label> x </label>
            <input type="text" id="endX">
            <label> y </label>
            <input type="text" id="endY">
            <button id="submitSegment"> ok </button>
            <br>
            <br>
            <button id="newPath"> New Path </button>
            <button id="done"> Done </button>
        </div>
        <div id="results">
        </div>
        <br>
        <br>
    </body>
    <script>
        
        let hasStarted = false;

        let xScale;
        let yScale;

        let startX;
        let startY;

        let paths = [];

        let START_SPEED = 20 /10;
        let CYCLE_SPEED = 30 /10;
        let TURN_SPEED_FACTOR = 0.95;
        let ACCEL = 5 / 1000;

        let startTime = 0;

        function start() {
            hasStarted = true;
            document.getElementById("mapInfo").style.visibility = "hidden";
            document.getElementById("data").style.visibility = "visible";
            let mapWidth = parseFloat(document.getElementById("width").value);
            let mapHeight = parseFloat(document.getElementById("height").value);
            startX = parseFloat(document.getElementById("startX").value);
            startY = parseFloat(document.getElementById("startY").value);

            xScale = width/mapWidth;
            yScale = height/mapHeight;
            paths.push(new Path(startX, startY));

            document.getElementById("endX").value = startX;
            document.getElementById("endY").value = startY;
        }

        function setup() {
            createCanvas(600, 600);
            fill(255);
            stroke(255);
        }

        function draw() {
            if (hasStarted) {
                background(0);
            } else {
                background(255);
            }
            for (let path of paths) {
                if (path.isActive) {
                    path.update();
                }
                path.show();
            }
        }

        document.getElementById("submitSegment").addEventListener("click", () => {
            let x = parseFloat(document.getElementById("endX").value);
            let y = parseFloat(document.getElementById("endY").value);
            let lastPath = paths[paths.length-1];
            lastPath.segments[lastPath.segments.length-1].update(x, y);
            lastPath.segments.push(new Segment(x, y));
        });

        document.getElementById("newPath").addEventListener("click", () => {
            paths.push(new Path(startX, startY));
            document.getElementById("endX").value = startX;
            document.getElementById("endY").value = startY;
        });
        
        document.getElementById("done").addEventListener("click", () => {
            startTime = frameCount;
            document.getElementById("results").innerHTML = "";
            for (let path of paths) {
                path.isActive = true;
                path.beginSimulation();
            }
        });

        class Path {

            constructor(startX, startY) {
                this.segments = [new Segment(startX, startY)];
                this.color = color(random(255), random(255), random(255));
                this.isActive = false;
                this.time = 0;
            }

            show() {
                fill(this.color);
                if (this.cycle) {
                    ellipse(this.cycle.x*xScale, this.cycle.y*yScale, 20, 20);
                }
                stroke(this.color);
                for (let segment of this.segments) {
                    segment.show();
                }
            }

            beginSimulation() {
                this.cycle = {
                    x: startX,
                    y: startY,
                    dx: 0,
                    dy: 0
                }
                this.currentSegmentIndex = 0;
                if (this.segments[0].direction == "right") {
                    this.cycle.dx = START_SPEED;
                } else if (this.segments[0].direction == "left") {
                    this.cycle.dx = -START_SPEED;
                } else if (this.segments[0].direction == "up") {
                    this.cycle.dy = -START_SPEED;
                } else if (this.segments[0].direction == "down") {
                    this.cycle.dy = START_SPEED;
                }
            }

            update() {
                this.cycle.x += this.cycle.dx;
                this.cycle.y += this.cycle.dy;

                if (abs(this.cycle.dx) + abs(this.cycle.dy) < CYCLE_SPEED) {
                    if (this.segments[this.currentSegmentIndex].direction == "right") {
                        this.cycle.dx += ACCEL;
                    } else if (this.segments[this.currentSegmentIndex].direction == "left") {
                        this.cycle.dx -= ACCEL;
                    } else if (this.segments[this.currentSegmentIndex].direction == "up") {
                        this.cycle.dy -= ACCEL;
                    } else if (this.segments[this.currentSegmentIndex].direction == "down") {
                        this.cycle.dy += ACCEL;
                    }
                }

                if (dist(this.cycle.x, this.cycle.y, this.segments[this.currentSegmentIndex].x2, this.segments[this.currentSegmentIndex].y2) <= abs(this.cycle.dx) + abs(this.cycle.dy)) {
                    if (this.currentSegmentIndex < this.segments.length - 1) {
                        this.cycle.x = this.segments[this.currentSegmentIndex].x2;
                        this.cycle.y = this.segments[this.currentSegmentIndex].y2;
                        this.currentSegmentIndex ++;
                        if (this.segments[this.currentSegmentIndex].direction == "right") {
                            this.cycle.dx = abs(this.cycle.dx + this.cycle.dy) * TURN_SPEED_FACTOR;
                            this.cycle.dy = 0;
                        } else if (this.segments[this.currentSegmentIndex].direction == "left") {
                            this.cycle.dx = -abs(this.cycle.dx + this.cycle.dy) * TURN_SPEED_FACTOR;
                            this.cycle.dy = 0;
                        } else if (this.segments[this.currentSegmentIndex].direction == "up") {
                            this.cycle.dy = -abs(this.cycle.dx + this.cycle.dy) * TURN_SPEED_FACTOR;
                            this.cycle.dx = 0;
                        } else if (this.segments[this.currentSegmentIndex].direction == "down") {
                            this.cycle.dy = abs(this.cycle.dx + this.cycle.dy) * TURN_SPEED_FACTOR;
                            this.cycle.dx = 0;
                        }
                    } else {
                        this.isActive = false;
                        this.time = frameCount - startTime;
                        let p = document.createElement("p");
                        p.innerHTML = this.time;
                        p.style.color = this.color;
                        document.getElementById("results").append(p);
                    }
                }
            }
        }

        class Segment {
            constructor(x1, y1) {
                this.x1 = x1;
                this.y1 = y1;
                this.x2 = x1;
                this.y2 = y1;
                this.length = 0;
                this.direction = "right";
            }

            update(x, y) {
                this.x2 = x;
                this.y2 = y;

                if (x > this.x1) {
                    this.direction = "right";
                } else if (x < this.x1) {
                    this.direction = "left";
                } else if (y < this.y1) {
                    this.direction = "up";
                } else if (y > this.y1) {
                    this.direction = "down";
                }
            }

            show() {
                line(this.x1*xScale, this.y1*yScale, this.x2*xScale, this.y2*xScale);
            }
        }

    </script>
</html>
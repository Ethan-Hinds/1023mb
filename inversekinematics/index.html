<html>
	<head>
		<meta charset="UTF-8" />
		<script src="https://cdn.jsdelivr.net/npm/p5@0.7.2/lib/p5.min.js"></script>
	</head>

	<body>
		<label> Number of segments</label>
		<input type = "text" id = "numSegments" value = "5" />
		<label> Segment Length </label>
		<input type = "text" id = "segmentLength" value = "80" />
		<input type = "checkbox" id = "allowCollisions" checked />
		<label> Allow Collisions </label> 
		<br>
		<br>
	</body>


	<script>

		var tolerance = 2;

		var armStartAngle = 125;

		var segments = [];
		var minAngles = {};

		var allowCollisions = true;

		class Segment {	
			constructor(x, y, length, parent, color) {
				this.x = x;
				this.y = y;
				this.length = length;
				this.color = color;

				this.endX = x;
				this.endY = y - length;
				this.angle = 0;
				this.parent = parent;
				this.child = undefined;
			}

			show() {
				strokeWeight(5);
				stroke(this.color	);
				line(this.x, this.y, this.endX, this.endY);
			}

			updatePosition() {
				if (this.parent) {
					this.x = this.parent.endX;
					this.y = this.parent.endY;
				}
				this.endX = this.x + this.length * cos(this.angle);
				this.endY = this.y - this.length * sin(this.angle);
			}

			setAngle(angle) {
				this.updatePosition();
				this.angle = angle != undefined ? angle : this.angle;
				this.child && this.child.setAngle();
			}
		}

		function setup() {
			createCanvas(700, 700);
			angleMode(DEGREES);

			let segmentLengthEl = document.querySelector("#segmentLength");
			segmentLengthEl.addEventListener("change", (event) => {
				let l = parseFloat(segmentLengthEl.value);
				for (let segment of segments) {
					segment.length = l;
				}
			});

			let numSegmentsEl = document.querySelector("#numSegments");
			numSegmentsEl.addEventListener("change", (event) => {
				let n = parseFloat(numSegmentsEl.value);
				if (n > 30) {
					n = 30;
					numSegmentsEl.value = 30;
				}
				let l = parseFloat(segmentLengthEl.value);
				segments = [];
				for (let i = 0; i < n; i += 1) {
					segments.push(new Segment(width*0.25, height/2 - 11.5, l, segments[segments.length - 1], color(random(50, 255), random(50, 255), random(50, 255))));
				}

				minAngles = {};
				for (let i = 0; i < segments.length; i += 1) {
					if (i < segments.length - 1) {
						segments[i].child = segments[i+1];
					}
					segments[i].updatePosition();
					minAngles[segments[i]] = 0;
				}
			});

			segments.push(new Segment(width*0.25, height/2 - 11.5, 60, undefined, color(random(50, 255), random(50, 255), random(50, 255))));
			segments.push(new Segment(width*0.25, height/2 - 11.5, 60, segments[segments.length-1], color(random(50, 255), random(50, 255), random(50, 255))));
			segments.push(new Segment(width*0.25, height/2 - 11.5, 60, segments[segments.length-1], color(random(50, 255), random(50, 255), random(50, 255))));
			segments.push(new Segment(width*0.25, height/2 - 11.5, 60, segments[segments.length-1], color(random(50, 255), random(50, 255), random(50, 255))));
			segments.push(new Segment(width*0.25, height/2 - 11.5, 60, segments[segments.length-1], color(random(50, 255), random(50, 255), random(50, 255))));

			for (let i = 0; i < segments.length; i += 1) {
				if (i < segments.length - 1) {
					segments[i].child = segments[i+1];
				}
				segments[i].updatePosition();
				minAngles[segments[i]] = 0;
			}

		}

		function getChildrenLength(segment) {
			let current = segment;
			let length = 0;
			while (current.child) {
				length += current.child.length;
				current = current.child;
			}
			return length;
		}

		function resetAllChildren(segment) {
			if (segment.child) {
				segment.child.setAngle(armStartAngle);
				resetAllChildren(segment.child);
			}
		}

		function rotateAround(segment, minDistance) {
			while (segment.angle >= armStartAngle - 360) {
				segment.setAngle(segment.angle - 1);
				if (dist(segment.endX, segment.endY, mouseX, mouseY) <= getChildrenLength(segment) + tolerance) {
					let lastSegment = segments[segments.length - 1];
					let distance = dist(lastSegment.endX, lastSegment.endY, mouseX, mouseY);
					let isIntersecting = false;
					if (!allowCollisions) {
						for (let i = 0; i < segments.length; i += 1) {
							let index = segments.indexOf(segment);

							if (abs(i-index) == 1) {
								let a1 = segment.angle;
								let a2 = segments[i].angle;
								let da = abs(a2 - a1);
								if (da > 160 && da < 200) {
									isIntersecting = true;
									break;
								}
							}

							if (abs(i-index) >= 2) {
								if (isIntersect(segments[i], segment)) {
									isIntersecting = true;
									break;
								}
							}
						}
					}
					if (isIntersecting) {
						continue;
					}
					if (distance < minDistance) {
						minDistance = distance;
						for (let seg of segments) {
							minAngles[seg] = seg.angle;
						}
					}
					if (distance < tolerance) {
						return true;
					}
					if (segment.child && rotateAround(segment.child, minDistance)) {
						return true;
					}
					resetAllChildren(segment);
				}
			}
			return false;
		}

		function onLine(segment, x, y) {
   			return (x <= max(segment.x, segment.endX) && x <= min(segment.x, segment.endX) && (segment.y <= max(segment.y, segment.endY) && y <= min(segment.y, segment.endY)));
		}

		function direction(ax, ay, bx, by, cx, cy) {
   			let val = (by-ay)*(cx-bx)-(bx-ax)*(cy-by);
   			if (val == 0) {
      			return 0;
			} else if(val < 0) {
      			return 2;
			}
      		return 1;
		}


		function isIntersect(segment1, segment2) {

			let dir1 = direction(segment1.x, segment1.y, segment1.endX, segment1.endY, segment2.x, segment2.y);
			let dir2 = direction(segment1.x, segment1.y, segment1.endX, segment1.endY, segment2.endX, segment2.endY);
			let dir3 = direction(segment2.x, segment2.y, segment2.endX, segment2.endY, segment1.x, segment1.y);
			let dir4 = direction(segment2.x, segment2.y, segment2.endX, segment2.endY, segment1.endX, segment1.endY);
   
			if (dir1 != dir2 && dir3 != dir4) {
				return true;
			}
			if (dir1==0 && onLine(segment1, segment2.x, segment2.y)) {
				return true;
			}
			if (dir2==0 && onLine(segment1, segment2.endX, segment2.endY)) {
				return true;
			}
			if (dir3==0 && onLine(segment2, segment1.x, segment1.y)) {
				return true;
			}
			if (dir4==0 && onLine(segment2, segment1.endX, segment1.endY)) {
				return true;
			}
   			return false;
		}

		function draw() {
			allowCollisions = document.getElementById("allowCollisions").checked;
			background(0);

			for (let segment of segments) {
				segment.setAngle(armStartAngle);
				segment.show();
			}

			let isPossible = rotateAround(segments[0], Infinity);
			if (!isPossible) {
				for (let segment of segments) {
					segment.setAngle(minAngles[segment]);
				}
			}
		}
	</script>
</html>

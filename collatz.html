<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.5.11/p5.js"></script>
</head>

<body>
    <button onclick="nextNum()"> Next </button>
    <input type = "checkbox" id = "autoCalc">
    <label> Auto Calculate (rip frames) </label> 
    <br>
</body>

<script>

    let tree;

    function setup() {
        createCanvas(700, 700);
        textAlign(CENTER, CENTER);
        background(0);
        tree = new Tree();
    }

    function draw() {
        background(0);
        if (document.getElementById("autoCalc").checked) {
            tree.levelOrderTraversal(tree.root);
        }
        tree.root.show();
    }

    function nextNum() {
        tree.levelOrderTraversal(tree.root);
    }

    class Num {
        constructor(value, height) {
            this.value = value;
            this.children = [];
            this.height = height;
        }

        show() {
            fill("#111155");
            ellipse(this.x, this.y, 2*tree.nodeRadius, 2*tree.nodeRadius);
            fill(255);
            text(this.value, this.x, this.y);

            if (this.children.length == 1) {
                let child = this.children[0];
                child.x = this.x;
                child.y = this.y - tree.dy;
                stroke(255);
                line(this.x, this.y - tree.nodeRadius, child.x, child.y);
                noStroke();
                child.show();
            } else if (this.children.length == 2) {
                let child1 = this.children[0];
                let child2 = this.children[1];
                child1.x = this.x - 500/(this.height**1.5);
                child1.y = this.y - tree.dy;
                child2.x = this.x + 500/(this.height**1.5);
                child2.y = this.y - tree.dy;
                stroke(255);
                line(this.x, this.y, child1.x, child1.y);
                line(this.x, this.y, child2.x, child2.y);
                noStroke();
                child1.show();
                child2.show();
            }

            // for (let i = 0; i < this.children.length; i += 1) {
            //     let child = this.children[i];
            //     let dx = i == 0 ? -tree.dx : tree.dx;
            //     child.x = this.x + dx;
            //     child.y = this.y - tree.dy;
            //     child.show();
            // }
        }

        calculateChildren() {
            let child1Val = this.value*2;
            let child2Val = (this.value-1)/3;
            for (let num of tree.nums) {
                if (num.value == child1Val) {
                    child1Val = -1;
                }
                if (num.value == child2Val) {
                    child2Val = -1;
                }
            }
            if (child1Val != -1) {
                let child = new Num(child1Val, this.height + 1)
                this.children.push(child);
                tree.nums.push(child)
                if (this.height + 1 > tree.height) {
                    tree.height = this.height + 1;
                    tree.nodeRadius *= 0.95;
                }
                tree.dy = height*0.75/tree.height;
            }
            if (child2Val%1 == 0 && child2Val != -1 && child2Val > 0) {
                let child = new Num(child2Val, this.height + 1);
                this.children.push(child);
                tree.nums.push(child);
                if (this.height + 1 > tree.height) {
                    tree.height = this.height + 1;
                    tree.nodeRadius *= 0.95;
                }
                tree.dy = height*0.75/tree.height;
            }
        }
    }

    class Tree {
        constructor() {
            this.nums = [];
            this.root = new Num(1, 0);
            this.root.x = width/2 - 10;
            this.root.y = height - 35;
            this.nums.push(this.root);
            this.height = 0;
            this.dy = height*0.75;
            this.nodeRadius = 25;
        }

        levelOrderTraversal(root) {
            if (root == null) {
                return;
            }
            let q = new Queue();
            q.push(root);
            while (!q.empty()) {
                let node = q.front();
                q.pop();
                if (node.children.length == 0) {

                    node.calculateChildren();
                    return;
                }
                for (let child of node.children) {
                    q.push(child);
                }
            }
        }
    }

    class Queue {
        constructor() {
            this.items = {};
            this.headIndex = 0;
            this.tailIndex = 0;
        }

        push(item) {
            this.items[this.tailIndex] = item;
            this.tailIndex++;
        }

        pop() {
            const item = this.items[this.headIndex];
            delete this.items[this.headIndex];
            this.headIndex++;
            return item;
        }

        front() {
            return this.items[this.headIndex];
        }

        length() {
            return this.tailIndex - this.headIndex;
        }

        empty() {
            return this.length() == 0;
        }
    }



</script>

</html>